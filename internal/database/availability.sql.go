// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: availability.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createAvailability = `-- name: CreateAvailability :one
insert into availability(id, created_at, updated_at, location, timing, duration, max_patient, current_patient, treatment, doctor_id)
values ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
returning id, created_at, updated_at, location, timing, duration, max_patient, current_patient, treatment, doctor_id
`

type CreateAvailabilityParams struct {
	ID             uuid.UUID
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Location       string
	Timing         time.Time
	Duration       int32
	MaxPatient     int32
	CurrentPatient int32
	Treatment      string
	DoctorID       uuid.UUID
}

func (q *Queries) CreateAvailability(ctx context.Context, arg CreateAvailabilityParams) (Availability, error) {
	row := q.db.QueryRowContext(ctx, createAvailability,
		arg.ID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Location,
		arg.Timing,
		arg.Duration,
		arg.MaxPatient,
		arg.CurrentPatient,
		arg.Treatment,
		arg.DoctorID,
	)
	var i Availability
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
		&i.Timing,
		&i.Duration,
		&i.MaxPatient,
		&i.CurrentPatient,
		&i.Treatment,
		&i.DoctorID,
	)
	return i, err
}

const delCurrentPatient = `-- name: DelCurrentPatient :one
update availability
set updated_at = NOW(),
current_patient = current_patient - 1
where id = $1 and timing > NOW() and current_patient > 0
returning id, created_at, updated_at, location, timing, duration, max_patient, current_patient, treatment, doctor_id
`

func (q *Queries) DelCurrentPatient(ctx context.Context, id uuid.UUID) (Availability, error) {
	row := q.db.QueryRowContext(ctx, delCurrentPatient, id)
	var i Availability
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
		&i.Timing,
		&i.Duration,
		&i.MaxPatient,
		&i.CurrentPatient,
		&i.Treatment,
		&i.DoctorID,
	)
	return i, err
}

const getAvailability = `-- name: GetAvailability :many
select a.id, a.created_at, a.updated_at, a.location, a.timing, a.duration, a.max_patient, a.current_patient, a.treatment, a.doctor_id,d.name,d.specialty from availability a
inner join doctor d
on a.doctor_id = d.id
where location like $1 and timing between $2 and $3
limit $4
offset $5
`

type GetAvailabilityParams struct {
	Location string
	Timing   time.Time
	Timing_2 time.Time
	Limit    int32
	Offset   int32
}

type GetAvailabilityRow struct {
	ID             uuid.UUID
	CreatedAt      time.Time
	UpdatedAt      time.Time
	Location       string
	Timing         time.Time
	Duration       int32
	MaxPatient     int32
	CurrentPatient int32
	Treatment      string
	DoctorID       uuid.UUID
	Name           string
	Specialty      string
}

func (q *Queries) GetAvailability(ctx context.Context, arg GetAvailabilityParams) ([]GetAvailabilityRow, error) {
	rows, err := q.db.QueryContext(ctx, getAvailability,
		arg.Location,
		arg.Timing,
		arg.Timing_2,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAvailabilityRow
	for rows.Next() {
		var i GetAvailabilityRow
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Location,
			&i.Timing,
			&i.Duration,
			&i.MaxPatient,
			&i.CurrentPatient,
			&i.Treatment,
			&i.DoctorID,
			&i.Name,
			&i.Specialty,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAvailabilityDoctor = `-- name: GetAvailabilityDoctor :many
select id, created_at, updated_at, location, timing, duration, max_patient, current_patient, treatment, doctor_id from availability
where location like $1 and timing between $2 and $3 and doctor_id = $4
limit $5
offset $6
`

type GetAvailabilityDoctorParams struct {
	Location string
	Timing   time.Time
	Timing_2 time.Time
	DoctorID uuid.UUID
	Limit    int32
	Offset   int32
}

func (q *Queries) GetAvailabilityDoctor(ctx context.Context, arg GetAvailabilityDoctorParams) ([]Availability, error) {
	rows, err := q.db.QueryContext(ctx, getAvailabilityDoctor,
		arg.Location,
		arg.Timing,
		arg.Timing_2,
		arg.DoctorID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Availability
	for rows.Next() {
		var i Availability
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Location,
			&i.Timing,
			&i.Duration,
			&i.MaxPatient,
			&i.CurrentPatient,
			&i.Treatment,
			&i.DoctorID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumAvailability = `-- name: GetNumAvailability :one
select count(*) from availability
where location like $1 and timing between $2 and $3
`

type GetNumAvailabilityParams struct {
	Location string
	Timing   time.Time
	Timing_2 time.Time
}

func (q *Queries) GetNumAvailability(ctx context.Context, arg GetNumAvailabilityParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNumAvailability, arg.Location, arg.Timing, arg.Timing_2)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getNumAvailabilityDoctor = `-- name: GetNumAvailabilityDoctor :one
select count(*) from availability
where location like $1 and timing between $2 and $3 and doctor_id = $4
`

type GetNumAvailabilityDoctorParams struct {
	Location string
	Timing   time.Time
	Timing_2 time.Time
	DoctorID uuid.UUID
}

func (q *Queries) GetNumAvailabilityDoctor(ctx context.Context, arg GetNumAvailabilityDoctorParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, getNumAvailabilityDoctor,
		arg.Location,
		arg.Timing,
		arg.Timing_2,
		arg.DoctorID,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const updateCurrentPatient = `-- name: UpdateCurrentPatient :one
update availability
set updated_at = NOW(),
current_patient = current_patient + 1
where id = $1 and timing > NOW() and current_patient < max_patient
returning id, created_at, updated_at, location, timing, duration, max_patient, current_patient, treatment, doctor_id
`

func (q *Queries) UpdateCurrentPatient(ctx context.Context, id uuid.UUID) (Availability, error) {
	row := q.db.QueryRowContext(ctx, updateCurrentPatient, id)
	var i Availability
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
		&i.Timing,
		&i.Duration,
		&i.MaxPatient,
		&i.CurrentPatient,
		&i.Treatment,
		&i.DoctorID,
	)
	return i, err
}
